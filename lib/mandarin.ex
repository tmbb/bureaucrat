defmodule Mandarin do
  @moduledoc """
  Uses some magic to generate an Admin framework for your application.
  """

  alias Mandarin.AccessorCreator
  alias Mandarin.ControllerCreator
  alias Mandarin.ViewCreator
  alias Mandarin.Routes
  alias Mandarin.Parameters
  alias Mandarin.GlobalParameters
  alias Mandarin.Debugger
  alias Mandarin.DebugConfig
  require ExUnit.Assertions, as: Assertions


  defmacro add_resource(module, options \\ []) do
    quote do
      Module.put_attribute(
        __MODULE__,
        :__mandarin_magik_resources__,
        {unquote(module), unquote(options)}
      )
    end
  end


  defp list_of_maps_to_map_of_lists(list_of_maps) do
    Enum.reduce(list_of_maps, %{}, fn new_map, acc1 ->
      Enum.reduce(new_map, acc1, fn {k, v}, acc2 ->
        Map.update(acc2, k, [v], fn values -> [v | values] end)
      end)
    end)
  end

  @doc false
  def build_resource(parameters) do
    schema = parameters.schema
    # We run these for the side effects;
    # The side effects are the creation of new modules.
    AccessorCreator.create_accessor(parameters)
    ControllerCreator.create_controller(parameters)
    {templates, _content} = ViewCreator.create_view(parameters)

    %{templates: {schema, templates}}
  end

  def build_resources(global_parameters, arguments) do
    resource_data_route_calls_pairs =
      for {schema, options} <- arguments do
          params = [
              global_parameters: global_parameters,
              schema: schema
          ]

          all_options = params ++ options

          parameters = Parameters.new(all_options)

          # Create the View, Controller and Accessor modules for our resource.
          resource_data = build_resource(parameters)

          # We run this for the value it returns;
          # This function is side effect-free
          route_calls = Routes.create_routes(parameters)

          {resource_data, route_calls}
        end

      {resource_data_maps, route_calls} = Enum.unzip(resource_data_route_calls_pairs)
      resource_data_map = list_of_maps_to_map_of_lists(resource_data_maps)

      {resource_data_map, route_calls}
  end

  @doc false
  def help() do
    IO.puts("""
    This Admin Interface was generated by Mandarin.
    """)
  end


  defmacro __before_compile__(env) do
    module = env.module

    repo = Module.get_attribute(module, :__mandarin_magik_repo__)
    app_web_namespace = Module.get_attribute(module, :__mandarin_magik_app_web_namespace__)
    scope = Module.get_attribute(module, :__mandarin_magik_scope__)
    arguments = Module.get_attribute(module, :__mandarin_magik_resources__)
    debug_arguments = Module.get_attribute(module, :__mandarin_magik_debug__)

    debug_config =
      case debug_arguments do
        nil -> DebugConfig.new()
        args -> DebugConfig.new(args)
      end

    # Consistency checks:
    Assertions.assert repo != nil
    Assertions.assert app_web_namespace != nil
    Assertions.assert scope != nil
    Assertions.assert is_atom(scope)
    Assertions.assert arguments != nil

    schemas = Enum.map(arguments, fn {schema, _} -> schema end)

    global_parameters = GlobalParameters.new(
      master_module: module,
      repo: repo,
      app_web_namespace: app_web_namespace,
      scope: scope,
      schemas: schemas,
      arguments: arguments
    )

    # Create the layout view from the global parameters
    # (later we'll create individual views for each resource)
    ViewCreator.create_layout_view(global_parameters)

    {resource_data, route_calls} = build_resources(global_parameters, arguments)
    # Assert that we are returning a map
    %{} = resource_data

    Debugger.debug(debug_config, resource_data)

    # You need to escape them or otherwise Elixir will try to
    # execute the router calls during macro expansion
    escaped_route_calls = Macro.escape(route_calls)
    escaped_global_parameters = Macro.escape(global_parameters)

    quote do
      require Mandarin

      @doc """
      Print help text for the Admin interface.
      """
      defdelegate help(), to: Mandarin

      @doc """
      Creates a scope in the router and adds the routes for the resources.

      The user can add extra routes under the macro body.
      Those routes will be matched before the automatically-defined routes.
      """
      defmacro scope(path, keywords) do
        Mandarin.Routes.__mandarin_scope__(
          unquote(escaped_global_parameters),
          path,
          unquote(escaped_route_calls),
          keywords
        )
      end
    end
  end

  defmacro __using__(options) do
    repo = Keyword.fetch!(options, :repo)
    app_web_namespace = Keyword.fetch!(options, :app_web)
    scope = Keyword.fetch!(options, :scope)
    debug = Keyword.get(options, :debug, [])

    quote do
      import Mandarin, only: [
        add_resource: 1,
        add_resource: 2
      ]

      @before_compile Mandarin

      Module.register_attribute(
        __MODULE__,
        :__mandarin_magik_resources__,
        accumulate: true
      )

      @__mandarin_magik_module__ __MODULE__
      @__mandarin_magik_repo__ unquote(repo)
      @__mandarin_magik_app_web_namespace__ unquote(app_web_namespace)
      @__mandarin_magik_scope__ unquote(scope)
      @__mandarin_magik_debug__ unquote(debug)

      def as_html(item), do: as_text(item)

      def as_text(%{__struct__: module} = _item) do
        module_alias =
          module
          |> inspect()
          |> String.split(".")
          |> List.last()

        "\##{module_alias}<...>"
      end

      defoverridable as_html: 1
      defoverridable as_text: 1
    end
  end
end

